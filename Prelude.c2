do := {fn-> fn} ;
id := {} ;
compose := {b a-> {a b}} ;
flip := {'swap swap compose} ;

dup := {a-> 'a 'a} ;
drop := {_->} ;
swap := {a b-> 'a 'b} ;
rot := {a b c-> 'a 'c 'b} ;
unrot := {a b c-> 'b 'a 'c} ;
dip := {f v-> f 'v} ;
nip := {swap drop} ;
tuck := {dup rot} ;
over := {swap tuck} ;

map := {_->} ;
map |= {f Some?-> f `Some} ;
map |= {f Right?-> f `Right} ;
map |= {f <<?-> f {'f map} dip <<} ;

foldr := {f v-> go := {>>?-> 'go dip f | _-> 'v} ; go} ;
foldl := {f v-> reverse 'v 'f foldr} ;

cat_maybes := {() {Some?-> >> | _->} foldr} ;
map_maybe := {map cat_maybes} ;
filter := {p?-> {dup p?: True?-> `Some | False? _-> None} map_maybe} ;
in := {val-> {'val =} filter len 0>} ;
reverse := {() '<< foldr} ;
zip := {>>? b, >>? a-> zip ('a, 'b) >> | _ _-> ()} ;
fst := {>>? nip} ;
snd := {>>? drop >>? nip} ;
tail := {>>? drop} ;
lst := {<<? nip} ;
init := {<<? drop} ;

either := {f _ Left? -> f | _ g Right? -> g} ;
lefts := {{Left? -> `Some | Right? _ -> None} map_maybe} ;
rights := {{Right? -> `Some | Left? _ -> None} map_maybe} ;
partition_eithers := {
	left := {l ()?-> ('l>>,)} ;
	right := {r ()?-> (,'r>>)} ;
	((),()) {'right 'left either} foldr} ;

fib := {2<? -> | dup 1 - fib swap 2 - fib +} ;

assert_bool? := {@dup True?-> | @dup False?->} ;
and := {True? @assert_bool?-> | @assert_bool? _ @assert_bool? _-> False} ;
or := {False? @assert_bool?-> | @assert_bool? _ @assert_bool? _-> True} ;
not := {True?-> False | False?-> True} ;

pi := 3.141592653589793 ;
tau := 6.283185307179586 ;
e := 2.718281828459045 ;
inv := {1 swap /} ;
comp := {1i * +} ;
comp? := {comp-> 'comp re 'comp im} ;
abs := {0>=? -> | 0<? -> ~ } ;
sgn := {0=?-> 0 | 0>? _-> 1 | 0<? _-> 1~} ;
max := {>=?-> | @swap >?->} ;
min := {<=?-> | @swap <?->} ;
evn := {2 %%} ;
odd := {evn not} ;
rand |= {@comp? 0 /=? -> rand 'rand dip comp} ;
sqrt := {0.5 ^} ;
cbrt := {1 3 / ^} ;
root := {recip ^} ;